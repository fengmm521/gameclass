// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Cmds.proto

#ifndef PROTOBUF_Cmds_2eproto__INCLUDED
#define PROTOBUF_Cmds_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace Cmd {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_Cmds_2eproto();
void protobuf_AssignDesc_Cmds_2eproto();
void protobuf_ShutdownFile_Cmds_2eproto();

class EchoTest;
class Login_Request;
class Login_Response;
class CreateRole_Request;
class Role;
class Hero;
class HeroList;
class Item;
class ItemList;
class Team;

// ===================================================================

class EchoTest : public ::google::protobuf::Message {
 public:
  EchoTest();
  virtual ~EchoTest();

  EchoTest(const EchoTest& from);

  inline EchoTest& operator=(const EchoTest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EchoTest& default_instance();

  void Swap(EchoTest* other);

  // implements Message ----------------------------------------------

  EchoTest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EchoTest& from);
  void MergeFrom(const EchoTest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double a = 1;
  inline bool has_a() const;
  inline void clear_a();
  static const int kAFieldNumber = 1;
  inline double a() const;
  inline void set_a(double value);

  // optional float b = 2;
  inline bool has_b() const;
  inline void clear_b();
  static const int kBFieldNumber = 2;
  inline float b() const;
  inline void set_b(float value);

  // optional sint32 c = 3;
  inline bool has_c() const;
  inline void clear_c();
  static const int kCFieldNumber = 3;
  inline ::google::protobuf::int32 c() const;
  inline void set_c(::google::protobuf::int32 value);

  // optional sint64 d = 4;
  inline bool has_d() const;
  inline void clear_d();
  static const int kDFieldNumber = 4;
  inline ::google::protobuf::int64 d() const;
  inline void set_d(::google::protobuf::int64 value);

  // optional bytes e = 5;
  inline bool has_e() const;
  inline void clear_e();
  static const int kEFieldNumber = 5;
  inline const ::std::string& e() const;
  inline void set_e(const ::std::string& value);
  inline void set_e(const char* value);
  inline void set_e(const void* value, size_t size);
  inline ::std::string* mutable_e();
  inline ::std::string* release_e();
  inline void set_allocated_e(::std::string* e);

  // @@protoc_insertion_point(class_scope:Cmd.EchoTest)
 private:
  inline void set_has_a();
  inline void clear_has_a();
  inline void set_has_b();
  inline void clear_has_b();
  inline void set_has_c();
  inline void clear_has_c();
  inline void set_has_d();
  inline void clear_has_d();
  inline void set_has_e();
  inline void clear_has_e();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  double a_;
  float b_;
  ::google::protobuf::int32 c_;
  ::google::protobuf::int64 d_;
  ::std::string* e_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_Cmds_2eproto();
  friend void protobuf_AssignDesc_Cmds_2eproto();
  friend void protobuf_ShutdownFile_Cmds_2eproto();

  void InitAsDefaultInstance();
  static EchoTest* default_instance_;
};
// -------------------------------------------------------------------

class Login_Request : public ::google::protobuf::Message {
 public:
  Login_Request();
  virtual ~Login_Request();

  Login_Request(const Login_Request& from);

  inline Login_Request& operator=(const Login_Request& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Login_Request& default_instance();

  void Swap(Login_Request* other);

  // implements Message ----------------------------------------------

  Login_Request* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Login_Request& from);
  void MergeFrom(const Login_Request& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes formid = 1;
  inline bool has_formid() const;
  inline void clear_formid();
  static const int kFormidFieldNumber = 1;
  inline const ::std::string& formid() const;
  inline void set_formid(const ::std::string& value);
  inline void set_formid(const char* value);
  inline void set_formid(const void* value, size_t size);
  inline ::std::string* mutable_formid();
  inline ::std::string* release_formid();
  inline void set_allocated_formid(::std::string* formid);

  // optional bytes fromuid = 2;
  inline bool has_fromuid() const;
  inline void clear_fromuid();
  static const int kFromuidFieldNumber = 2;
  inline const ::std::string& fromuid() const;
  inline void set_fromuid(const ::std::string& value);
  inline void set_fromuid(const char* value);
  inline void set_fromuid(const void* value, size_t size);
  inline ::std::string* mutable_fromuid();
  inline ::std::string* release_fromuid();
  inline void set_allocated_fromuid(::std::string* fromuid);

  // optional bytes session = 3;
  inline bool has_session() const;
  inline void clear_session();
  static const int kSessionFieldNumber = 3;
  inline const ::std::string& session() const;
  inline void set_session(const ::std::string& value);
  inline void set_session(const char* value);
  inline void set_session(const void* value, size_t size);
  inline ::std::string* mutable_session();
  inline ::std::string* release_session();
  inline void set_allocated_session(::std::string* session);

  // optional bytes token = 4;
  inline bool has_token() const;
  inline void clear_token();
  static const int kTokenFieldNumber = 4;
  inline const ::std::string& token() const;
  inline void set_token(const ::std::string& value);
  inline void set_token(const char* value);
  inline void set_token(const void* value, size_t size);
  inline ::std::string* mutable_token();
  inline ::std::string* release_token();
  inline void set_allocated_token(::std::string* token);

  // optional bytes version = 5;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 5;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const void* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  inline void set_allocated_version(::std::string* version);

  // optional bytes device = 6;
  inline bool has_device() const;
  inline void clear_device();
  static const int kDeviceFieldNumber = 6;
  inline const ::std::string& device() const;
  inline void set_device(const ::std::string& value);
  inline void set_device(const char* value);
  inline void set_device(const void* value, size_t size);
  inline ::std::string* mutable_device();
  inline ::std::string* release_device();
  inline void set_allocated_device(::std::string* device);

  // optional bytes system = 7;
  inline bool has_system() const;
  inline void clear_system();
  static const int kSystemFieldNumber = 7;
  inline const ::std::string& system() const;
  inline void set_system(const ::std::string& value);
  inline void set_system(const char* value);
  inline void set_system(const void* value, size_t size);
  inline ::std::string* mutable_system();
  inline ::std::string* release_system();
  inline void set_allocated_system(::std::string* system);

  // optional bytes uniqueness = 8;
  inline bool has_uniqueness() const;
  inline void clear_uniqueness();
  static const int kUniquenessFieldNumber = 8;
  inline const ::std::string& uniqueness() const;
  inline void set_uniqueness(const ::std::string& value);
  inline void set_uniqueness(const char* value);
  inline void set_uniqueness(const void* value, size_t size);
  inline ::std::string* mutable_uniqueness();
  inline ::std::string* release_uniqueness();
  inline void set_allocated_uniqueness(::std::string* uniqueness);

  // @@protoc_insertion_point(class_scope:Cmd.Login_Request)
 private:
  inline void set_has_formid();
  inline void clear_has_formid();
  inline void set_has_fromuid();
  inline void clear_has_fromuid();
  inline void set_has_session();
  inline void clear_has_session();
  inline void set_has_token();
  inline void clear_has_token();
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_device();
  inline void clear_has_device();
  inline void set_has_system();
  inline void clear_has_system();
  inline void set_has_uniqueness();
  inline void clear_has_uniqueness();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* formid_;
  ::std::string* fromuid_;
  ::std::string* session_;
  ::std::string* token_;
  ::std::string* version_;
  ::std::string* device_;
  ::std::string* system_;
  ::std::string* uniqueness_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_Cmds_2eproto();
  friend void protobuf_AssignDesc_Cmds_2eproto();
  friend void protobuf_ShutdownFile_Cmds_2eproto();

  void InitAsDefaultInstance();
  static Login_Request* default_instance_;
};
// -------------------------------------------------------------------

class Login_Response : public ::google::protobuf::Message {
 public:
  Login_Response();
  virtual ~Login_Response();

  Login_Response(const Login_Response& from);

  inline Login_Response& operator=(const Login_Response& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Login_Response& default_instance();

  void Swap(Login_Response* other);

  // implements Message ----------------------------------------------

  Login_Response* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Login_Response& from);
  void MergeFrom(const Login_Response& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes uid = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  inline const ::std::string& uid() const;
  inline void set_uid(const ::std::string& value);
  inline void set_uid(const char* value);
  inline void set_uid(const void* value, size_t size);
  inline ::std::string* mutable_uid();
  inline ::std::string* release_uid();
  inline void set_allocated_uid(::std::string* uid);

  // optional bytes fromuid = 2;
  inline bool has_fromuid() const;
  inline void clear_fromuid();
  static const int kFromuidFieldNumber = 2;
  inline const ::std::string& fromuid() const;
  inline void set_fromuid(const ::std::string& value);
  inline void set_fromuid(const char* value);
  inline void set_fromuid(const void* value, size_t size);
  inline ::std::string* mutable_fromuid();
  inline ::std::string* release_fromuid();
  inline void set_allocated_fromuid(::std::string* fromuid);

  // @@protoc_insertion_point(class_scope:Cmd.Login_Response)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_fromuid();
  inline void clear_has_fromuid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* uid_;
  ::std::string* fromuid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_Cmds_2eproto();
  friend void protobuf_AssignDesc_Cmds_2eproto();
  friend void protobuf_ShutdownFile_Cmds_2eproto();

  void InitAsDefaultInstance();
  static Login_Response* default_instance_;
};
// -------------------------------------------------------------------

class CreateRole_Request : public ::google::protobuf::Message {
 public:
  CreateRole_Request();
  virtual ~CreateRole_Request();

  CreateRole_Request(const CreateRole_Request& from);

  inline CreateRole_Request& operator=(const CreateRole_Request& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CreateRole_Request& default_instance();

  void Swap(CreateRole_Request* other);

  // implements Message ----------------------------------------------

  CreateRole_Request* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CreateRole_Request& from);
  void MergeFrom(const CreateRole_Request& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional sint32 figure = 1;
  inline bool has_figure() const;
  inline void clear_figure();
  static const int kFigureFieldNumber = 1;
  inline ::google::protobuf::int32 figure() const;
  inline void set_figure(::google::protobuf::int32 value);

  // optional bytes name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const void* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:Cmd.CreateRole_Request)
 private:
  inline void set_has_figure();
  inline void clear_has_figure();
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::google::protobuf::int32 figure_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_Cmds_2eproto();
  friend void protobuf_AssignDesc_Cmds_2eproto();
  friend void protobuf_ShutdownFile_Cmds_2eproto();

  void InitAsDefaultInstance();
  static CreateRole_Request* default_instance_;
};
// -------------------------------------------------------------------

class Role : public ::google::protobuf::Message {
 public:
  Role();
  virtual ~Role();

  Role(const Role& from);

  inline Role& operator=(const Role& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Role& default_instance();

  void Swap(Role* other);

  // implements Message ----------------------------------------------

  Role* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Role& from);
  void MergeFrom(const Role& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional sint32 figure = 1;
  inline bool has_figure() const;
  inline void clear_figure();
  static const int kFigureFieldNumber = 1;
  inline ::google::protobuf::int32 figure() const;
  inline void set_figure(::google::protobuf::int32 value);

  // optional sint32 viplv = 2;
  inline bool has_viplv() const;
  inline void clear_viplv();
  static const int kViplvFieldNumber = 2;
  inline ::google::protobuf::int32 viplv() const;
  inline void set_viplv(::google::protobuf::int32 value);

  // optional sint32 viptub = 3;
  inline bool has_viptub() const;
  inline void clear_viptub();
  static const int kViptubFieldNumber = 3;
  inline ::google::protobuf::int32 viptub() const;
  inline void set_viptub(::google::protobuf::int32 value);

  // optional sint32 mclv = 4;
  inline bool has_mclv() const;
  inline void clear_mclv();
  static const int kMclvFieldNumber = 4;
  inline ::google::protobuf::int32 mclv() const;
  inline void set_mclv(::google::protobuf::int32 value);

  // optional sint32 mctub = 5;
  inline bool has_mctub() const;
  inline void clear_mctub();
  static const int kMctubFieldNumber = 5;
  inline ::google::protobuf::int32 mctub() const;
  inline void set_mctub(::google::protobuf::int32 value);

  // optional sint32 newbies = 6;
  inline bool has_newbies() const;
  inline void clear_newbies();
  static const int kNewbiesFieldNumber = 6;
  inline ::google::protobuf::int32 newbies() const;
  inline void set_newbies(::google::protobuf::int32 value);

  // optional bytes name = 7;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 7;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const void* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:Cmd.Role)
 private:
  inline void set_has_figure();
  inline void clear_has_figure();
  inline void set_has_viplv();
  inline void clear_has_viplv();
  inline void set_has_viptub();
  inline void clear_has_viptub();
  inline void set_has_mclv();
  inline void clear_has_mclv();
  inline void set_has_mctub();
  inline void clear_has_mctub();
  inline void set_has_newbies();
  inline void clear_has_newbies();
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 figure_;
  ::google::protobuf::int32 viplv_;
  ::google::protobuf::int32 viptub_;
  ::google::protobuf::int32 mclv_;
  ::google::protobuf::int32 mctub_;
  ::google::protobuf::int32 newbies_;
  ::std::string* name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_Cmds_2eproto();
  friend void protobuf_AssignDesc_Cmds_2eproto();
  friend void protobuf_ShutdownFile_Cmds_2eproto();

  void InitAsDefaultInstance();
  static Role* default_instance_;
};
// -------------------------------------------------------------------

class Hero : public ::google::protobuf::Message {
 public:
  Hero();
  virtual ~Hero();

  Hero(const Hero& from);

  inline Hero& operator=(const Hero& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Hero& default_instance();

  void Swap(Hero* other);

  // implements Message ----------------------------------------------

  Hero* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Hero& from);
  void MergeFrom(const Hero& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional sint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // optional sint32 tid = 2;
  inline bool has_tid() const;
  inline void clear_tid();
  static const int kTidFieldNumber = 2;
  inline ::google::protobuf::int32 tid() const;
  inline void set_tid(::google::protobuf::int32 value);

  // optional sint32 level = 3;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 3;
  inline ::google::protobuf::int32 level() const;
  inline void set_level(::google::protobuf::int32 value);

  // optional sint32 exptub = 4;
  inline bool has_exptub() const;
  inline void clear_exptub();
  static const int kExptubFieldNumber = 4;
  inline ::google::protobuf::int32 exptub() const;
  inline void set_exptub(::google::protobuf::int32 value);

  // optional sint32 advlv = 5;
  inline bool has_advlv() const;
  inline void clear_advlv();
  static const int kAdvlvFieldNumber = 5;
  inline ::google::protobuf::int32 advlv() const;
  inline void set_advlv(::google::protobuf::int32 value);

  // optional sint32 qualv = 6;
  inline bool has_qualv() const;
  inline void clear_qualv();
  static const int kQualvFieldNumber = 6;
  inline ::google::protobuf::int32 qualv() const;
  inline void set_qualv(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Cmd.Hero)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_tid();
  inline void clear_has_tid();
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_exptub();
  inline void clear_has_exptub();
  inline void set_has_advlv();
  inline void clear_has_advlv();
  inline void set_has_qualv();
  inline void clear_has_qualv();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 tid_;
  ::google::protobuf::int32 level_;
  ::google::protobuf::int32 exptub_;
  ::google::protobuf::int32 advlv_;
  ::google::protobuf::int32 qualv_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_Cmds_2eproto();
  friend void protobuf_AssignDesc_Cmds_2eproto();
  friend void protobuf_ShutdownFile_Cmds_2eproto();

  void InitAsDefaultInstance();
  static Hero* default_instance_;
};
// -------------------------------------------------------------------

class HeroList : public ::google::protobuf::Message {
 public:
  HeroList();
  virtual ~HeroList();

  HeroList(const HeroList& from);

  inline HeroList& operator=(const HeroList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HeroList& default_instance();

  void Swap(HeroList* other);

  // implements Message ----------------------------------------------

  HeroList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HeroList& from);
  void MergeFrom(const HeroList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Cmd.Hero list = 1;
  inline int list_size() const;
  inline void clear_list();
  static const int kListFieldNumber = 1;
  inline const ::Cmd::Hero& list(int index) const;
  inline ::Cmd::Hero* mutable_list(int index);
  inline ::Cmd::Hero* add_list();
  inline const ::google::protobuf::RepeatedPtrField< ::Cmd::Hero >&
      list() const;
  inline ::google::protobuf::RepeatedPtrField< ::Cmd::Hero >*
      mutable_list();

  // @@protoc_insertion_point(class_scope:Cmd.HeroList)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::Cmd::Hero > list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_Cmds_2eproto();
  friend void protobuf_AssignDesc_Cmds_2eproto();
  friend void protobuf_ShutdownFile_Cmds_2eproto();

  void InitAsDefaultInstance();
  static HeroList* default_instance_;
};
// -------------------------------------------------------------------

class Item : public ::google::protobuf::Message {
 public:
  Item();
  virtual ~Item();

  Item(const Item& from);

  inline Item& operator=(const Item& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Item& default_instance();

  void Swap(Item* other);

  // implements Message ----------------------------------------------

  Item* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Item& from);
  void MergeFrom(const Item& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional sint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // optional sint32 tid = 2;
  inline bool has_tid() const;
  inline void clear_tid();
  static const int kTidFieldNumber = 2;
  inline ::google::protobuf::int32 tid() const;
  inline void set_tid(::google::protobuf::int32 value);

  // optional sint32 num = 3;
  inline bool has_num() const;
  inline void clear_num();
  static const int kNumFieldNumber = 3;
  inline ::google::protobuf::int32 num() const;
  inline void set_num(::google::protobuf::int32 value);

  // optional sint32 level = 4;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 4;
  inline ::google::protobuf::int32 level() const;
  inline void set_level(::google::protobuf::int32 value);

  // optional sint32 htid = 5;
  inline bool has_htid() const;
  inline void clear_htid();
  static const int kHtidFieldNumber = 5;
  inline ::google::protobuf::int32 htid() const;
  inline void set_htid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Cmd.Item)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_tid();
  inline void clear_has_tid();
  inline void set_has_num();
  inline void clear_has_num();
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_htid();
  inline void clear_has_htid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 tid_;
  ::google::protobuf::int32 num_;
  ::google::protobuf::int32 level_;
  ::google::protobuf::int32 htid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_Cmds_2eproto();
  friend void protobuf_AssignDesc_Cmds_2eproto();
  friend void protobuf_ShutdownFile_Cmds_2eproto();

  void InitAsDefaultInstance();
  static Item* default_instance_;
};
// -------------------------------------------------------------------

class ItemList : public ::google::protobuf::Message {
 public:
  ItemList();
  virtual ~ItemList();

  ItemList(const ItemList& from);

  inline ItemList& operator=(const ItemList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ItemList& default_instance();

  void Swap(ItemList* other);

  // implements Message ----------------------------------------------

  ItemList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ItemList& from);
  void MergeFrom(const ItemList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Cmd.Item list = 1;
  inline int list_size() const;
  inline void clear_list();
  static const int kListFieldNumber = 1;
  inline const ::Cmd::Item& list(int index) const;
  inline ::Cmd::Item* mutable_list(int index);
  inline ::Cmd::Item* add_list();
  inline const ::google::protobuf::RepeatedPtrField< ::Cmd::Item >&
      list() const;
  inline ::google::protobuf::RepeatedPtrField< ::Cmd::Item >*
      mutable_list();

  // @@protoc_insertion_point(class_scope:Cmd.ItemList)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::Cmd::Item > list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_Cmds_2eproto();
  friend void protobuf_AssignDesc_Cmds_2eproto();
  friend void protobuf_ShutdownFile_Cmds_2eproto();

  void InitAsDefaultInstance();
  static ItemList* default_instance_;
};
// -------------------------------------------------------------------

class Team : public ::google::protobuf::Message {
 public:
  Team();
  virtual ~Team();

  Team(const Team& from);

  inline Team& operator=(const Team& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Team& default_instance();

  void Swap(Team* other);

  // implements Message ----------------------------------------------

  Team* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Team& from);
  void MergeFrom(const Team& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated sint32 list = 1;
  inline int list_size() const;
  inline void clear_list();
  static const int kListFieldNumber = 1;
  inline ::google::protobuf::int32 list(int index) const;
  inline void set_list(int index, ::google::protobuf::int32 value);
  inline void add_list(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      list() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_list();

  // @@protoc_insertion_point(class_scope:Cmd.Team)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_Cmds_2eproto();
  friend void protobuf_AssignDesc_Cmds_2eproto();
  friend void protobuf_ShutdownFile_Cmds_2eproto();

  void InitAsDefaultInstance();
  static Team* default_instance_;
};
// ===================================================================


// ===================================================================

// EchoTest

// optional double a = 1;
inline bool EchoTest::has_a() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EchoTest::set_has_a() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EchoTest::clear_has_a() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EchoTest::clear_a() {
  a_ = 0;
  clear_has_a();
}
inline double EchoTest::a() const {
  return a_;
}
inline void EchoTest::set_a(double value) {
  set_has_a();
  a_ = value;
}

// optional float b = 2;
inline bool EchoTest::has_b() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EchoTest::set_has_b() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EchoTest::clear_has_b() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EchoTest::clear_b() {
  b_ = 0;
  clear_has_b();
}
inline float EchoTest::b() const {
  return b_;
}
inline void EchoTest::set_b(float value) {
  set_has_b();
  b_ = value;
}

// optional sint32 c = 3;
inline bool EchoTest::has_c() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EchoTest::set_has_c() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EchoTest::clear_has_c() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EchoTest::clear_c() {
  c_ = 0;
  clear_has_c();
}
inline ::google::protobuf::int32 EchoTest::c() const {
  return c_;
}
inline void EchoTest::set_c(::google::protobuf::int32 value) {
  set_has_c();
  c_ = value;
}

// optional sint64 d = 4;
inline bool EchoTest::has_d() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void EchoTest::set_has_d() {
  _has_bits_[0] |= 0x00000008u;
}
inline void EchoTest::clear_has_d() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void EchoTest::clear_d() {
  d_ = GOOGLE_LONGLONG(0);
  clear_has_d();
}
inline ::google::protobuf::int64 EchoTest::d() const {
  return d_;
}
inline void EchoTest::set_d(::google::protobuf::int64 value) {
  set_has_d();
  d_ = value;
}

// optional bytes e = 5;
inline bool EchoTest::has_e() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void EchoTest::set_has_e() {
  _has_bits_[0] |= 0x00000010u;
}
inline void EchoTest::clear_has_e() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void EchoTest::clear_e() {
  if (e_ != &::google::protobuf::internal::kEmptyString) {
    e_->clear();
  }
  clear_has_e();
}
inline const ::std::string& EchoTest::e() const {
  return *e_;
}
inline void EchoTest::set_e(const ::std::string& value) {
  set_has_e();
  if (e_ == &::google::protobuf::internal::kEmptyString) {
    e_ = new ::std::string;
  }
  e_->assign(value);
}
inline void EchoTest::set_e(const char* value) {
  set_has_e();
  if (e_ == &::google::protobuf::internal::kEmptyString) {
    e_ = new ::std::string;
  }
  e_->assign(value);
}
inline void EchoTest::set_e(const void* value, size_t size) {
  set_has_e();
  if (e_ == &::google::protobuf::internal::kEmptyString) {
    e_ = new ::std::string;
  }
  e_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EchoTest::mutable_e() {
  set_has_e();
  if (e_ == &::google::protobuf::internal::kEmptyString) {
    e_ = new ::std::string;
  }
  return e_;
}
inline ::std::string* EchoTest::release_e() {
  clear_has_e();
  if (e_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = e_;
    e_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void EchoTest::set_allocated_e(::std::string* e) {
  if (e_ != &::google::protobuf::internal::kEmptyString) {
    delete e_;
  }
  if (e) {
    set_has_e();
    e_ = e;
  } else {
    clear_has_e();
    e_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Login_Request

// optional bytes formid = 1;
inline bool Login_Request::has_formid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Login_Request::set_has_formid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Login_Request::clear_has_formid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Login_Request::clear_formid() {
  if (formid_ != &::google::protobuf::internal::kEmptyString) {
    formid_->clear();
  }
  clear_has_formid();
}
inline const ::std::string& Login_Request::formid() const {
  return *formid_;
}
inline void Login_Request::set_formid(const ::std::string& value) {
  set_has_formid();
  if (formid_ == &::google::protobuf::internal::kEmptyString) {
    formid_ = new ::std::string;
  }
  formid_->assign(value);
}
inline void Login_Request::set_formid(const char* value) {
  set_has_formid();
  if (formid_ == &::google::protobuf::internal::kEmptyString) {
    formid_ = new ::std::string;
  }
  formid_->assign(value);
}
inline void Login_Request::set_formid(const void* value, size_t size) {
  set_has_formid();
  if (formid_ == &::google::protobuf::internal::kEmptyString) {
    formid_ = new ::std::string;
  }
  formid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Login_Request::mutable_formid() {
  set_has_formid();
  if (formid_ == &::google::protobuf::internal::kEmptyString) {
    formid_ = new ::std::string;
  }
  return formid_;
}
inline ::std::string* Login_Request::release_formid() {
  clear_has_formid();
  if (formid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = formid_;
    formid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Login_Request::set_allocated_formid(::std::string* formid) {
  if (formid_ != &::google::protobuf::internal::kEmptyString) {
    delete formid_;
  }
  if (formid) {
    set_has_formid();
    formid_ = formid;
  } else {
    clear_has_formid();
    formid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes fromuid = 2;
inline bool Login_Request::has_fromuid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Login_Request::set_has_fromuid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Login_Request::clear_has_fromuid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Login_Request::clear_fromuid() {
  if (fromuid_ != &::google::protobuf::internal::kEmptyString) {
    fromuid_->clear();
  }
  clear_has_fromuid();
}
inline const ::std::string& Login_Request::fromuid() const {
  return *fromuid_;
}
inline void Login_Request::set_fromuid(const ::std::string& value) {
  set_has_fromuid();
  if (fromuid_ == &::google::protobuf::internal::kEmptyString) {
    fromuid_ = new ::std::string;
  }
  fromuid_->assign(value);
}
inline void Login_Request::set_fromuid(const char* value) {
  set_has_fromuid();
  if (fromuid_ == &::google::protobuf::internal::kEmptyString) {
    fromuid_ = new ::std::string;
  }
  fromuid_->assign(value);
}
inline void Login_Request::set_fromuid(const void* value, size_t size) {
  set_has_fromuid();
  if (fromuid_ == &::google::protobuf::internal::kEmptyString) {
    fromuid_ = new ::std::string;
  }
  fromuid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Login_Request::mutable_fromuid() {
  set_has_fromuid();
  if (fromuid_ == &::google::protobuf::internal::kEmptyString) {
    fromuid_ = new ::std::string;
  }
  return fromuid_;
}
inline ::std::string* Login_Request::release_fromuid() {
  clear_has_fromuid();
  if (fromuid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = fromuid_;
    fromuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Login_Request::set_allocated_fromuid(::std::string* fromuid) {
  if (fromuid_ != &::google::protobuf::internal::kEmptyString) {
    delete fromuid_;
  }
  if (fromuid) {
    set_has_fromuid();
    fromuid_ = fromuid;
  } else {
    clear_has_fromuid();
    fromuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes session = 3;
inline bool Login_Request::has_session() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Login_Request::set_has_session() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Login_Request::clear_has_session() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Login_Request::clear_session() {
  if (session_ != &::google::protobuf::internal::kEmptyString) {
    session_->clear();
  }
  clear_has_session();
}
inline const ::std::string& Login_Request::session() const {
  return *session_;
}
inline void Login_Request::set_session(const ::std::string& value) {
  set_has_session();
  if (session_ == &::google::protobuf::internal::kEmptyString) {
    session_ = new ::std::string;
  }
  session_->assign(value);
}
inline void Login_Request::set_session(const char* value) {
  set_has_session();
  if (session_ == &::google::protobuf::internal::kEmptyString) {
    session_ = new ::std::string;
  }
  session_->assign(value);
}
inline void Login_Request::set_session(const void* value, size_t size) {
  set_has_session();
  if (session_ == &::google::protobuf::internal::kEmptyString) {
    session_ = new ::std::string;
  }
  session_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Login_Request::mutable_session() {
  set_has_session();
  if (session_ == &::google::protobuf::internal::kEmptyString) {
    session_ = new ::std::string;
  }
  return session_;
}
inline ::std::string* Login_Request::release_session() {
  clear_has_session();
  if (session_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = session_;
    session_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Login_Request::set_allocated_session(::std::string* session) {
  if (session_ != &::google::protobuf::internal::kEmptyString) {
    delete session_;
  }
  if (session) {
    set_has_session();
    session_ = session;
  } else {
    clear_has_session();
    session_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes token = 4;
inline bool Login_Request::has_token() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Login_Request::set_has_token() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Login_Request::clear_has_token() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Login_Request::clear_token() {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    token_->clear();
  }
  clear_has_token();
}
inline const ::std::string& Login_Request::token() const {
  return *token_;
}
inline void Login_Request::set_token(const ::std::string& value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void Login_Request::set_token(const char* value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void Login_Request::set_token(const void* value, size_t size) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Login_Request::mutable_token() {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  return token_;
}
inline ::std::string* Login_Request::release_token() {
  clear_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = token_;
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Login_Request::set_allocated_token(::std::string* token) {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    delete token_;
  }
  if (token) {
    set_has_token();
    token_ = token;
  } else {
    clear_has_token();
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes version = 5;
inline bool Login_Request::has_version() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Login_Request::set_has_version() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Login_Request::clear_has_version() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Login_Request::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& Login_Request::version() const {
  return *version_;
}
inline void Login_Request::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void Login_Request::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void Login_Request::set_version(const void* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Login_Request::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* Login_Request::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Login_Request::set_allocated_version(::std::string* version) {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    delete version_;
  }
  if (version) {
    set_has_version();
    version_ = version;
  } else {
    clear_has_version();
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes device = 6;
inline bool Login_Request::has_device() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Login_Request::set_has_device() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Login_Request::clear_has_device() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Login_Request::clear_device() {
  if (device_ != &::google::protobuf::internal::kEmptyString) {
    device_->clear();
  }
  clear_has_device();
}
inline const ::std::string& Login_Request::device() const {
  return *device_;
}
inline void Login_Request::set_device(const ::std::string& value) {
  set_has_device();
  if (device_ == &::google::protobuf::internal::kEmptyString) {
    device_ = new ::std::string;
  }
  device_->assign(value);
}
inline void Login_Request::set_device(const char* value) {
  set_has_device();
  if (device_ == &::google::protobuf::internal::kEmptyString) {
    device_ = new ::std::string;
  }
  device_->assign(value);
}
inline void Login_Request::set_device(const void* value, size_t size) {
  set_has_device();
  if (device_ == &::google::protobuf::internal::kEmptyString) {
    device_ = new ::std::string;
  }
  device_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Login_Request::mutable_device() {
  set_has_device();
  if (device_ == &::google::protobuf::internal::kEmptyString) {
    device_ = new ::std::string;
  }
  return device_;
}
inline ::std::string* Login_Request::release_device() {
  clear_has_device();
  if (device_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = device_;
    device_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Login_Request::set_allocated_device(::std::string* device) {
  if (device_ != &::google::protobuf::internal::kEmptyString) {
    delete device_;
  }
  if (device) {
    set_has_device();
    device_ = device;
  } else {
    clear_has_device();
    device_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes system = 7;
inline bool Login_Request::has_system() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Login_Request::set_has_system() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Login_Request::clear_has_system() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Login_Request::clear_system() {
  if (system_ != &::google::protobuf::internal::kEmptyString) {
    system_->clear();
  }
  clear_has_system();
}
inline const ::std::string& Login_Request::system() const {
  return *system_;
}
inline void Login_Request::set_system(const ::std::string& value) {
  set_has_system();
  if (system_ == &::google::protobuf::internal::kEmptyString) {
    system_ = new ::std::string;
  }
  system_->assign(value);
}
inline void Login_Request::set_system(const char* value) {
  set_has_system();
  if (system_ == &::google::protobuf::internal::kEmptyString) {
    system_ = new ::std::string;
  }
  system_->assign(value);
}
inline void Login_Request::set_system(const void* value, size_t size) {
  set_has_system();
  if (system_ == &::google::protobuf::internal::kEmptyString) {
    system_ = new ::std::string;
  }
  system_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Login_Request::mutable_system() {
  set_has_system();
  if (system_ == &::google::protobuf::internal::kEmptyString) {
    system_ = new ::std::string;
  }
  return system_;
}
inline ::std::string* Login_Request::release_system() {
  clear_has_system();
  if (system_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = system_;
    system_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Login_Request::set_allocated_system(::std::string* system) {
  if (system_ != &::google::protobuf::internal::kEmptyString) {
    delete system_;
  }
  if (system) {
    set_has_system();
    system_ = system;
  } else {
    clear_has_system();
    system_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes uniqueness = 8;
inline bool Login_Request::has_uniqueness() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Login_Request::set_has_uniqueness() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Login_Request::clear_has_uniqueness() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Login_Request::clear_uniqueness() {
  if (uniqueness_ != &::google::protobuf::internal::kEmptyString) {
    uniqueness_->clear();
  }
  clear_has_uniqueness();
}
inline const ::std::string& Login_Request::uniqueness() const {
  return *uniqueness_;
}
inline void Login_Request::set_uniqueness(const ::std::string& value) {
  set_has_uniqueness();
  if (uniqueness_ == &::google::protobuf::internal::kEmptyString) {
    uniqueness_ = new ::std::string;
  }
  uniqueness_->assign(value);
}
inline void Login_Request::set_uniqueness(const char* value) {
  set_has_uniqueness();
  if (uniqueness_ == &::google::protobuf::internal::kEmptyString) {
    uniqueness_ = new ::std::string;
  }
  uniqueness_->assign(value);
}
inline void Login_Request::set_uniqueness(const void* value, size_t size) {
  set_has_uniqueness();
  if (uniqueness_ == &::google::protobuf::internal::kEmptyString) {
    uniqueness_ = new ::std::string;
  }
  uniqueness_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Login_Request::mutable_uniqueness() {
  set_has_uniqueness();
  if (uniqueness_ == &::google::protobuf::internal::kEmptyString) {
    uniqueness_ = new ::std::string;
  }
  return uniqueness_;
}
inline ::std::string* Login_Request::release_uniqueness() {
  clear_has_uniqueness();
  if (uniqueness_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uniqueness_;
    uniqueness_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Login_Request::set_allocated_uniqueness(::std::string* uniqueness) {
  if (uniqueness_ != &::google::protobuf::internal::kEmptyString) {
    delete uniqueness_;
  }
  if (uniqueness) {
    set_has_uniqueness();
    uniqueness_ = uniqueness;
  } else {
    clear_has_uniqueness();
    uniqueness_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Login_Response

// optional bytes uid = 1;
inline bool Login_Response::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Login_Response::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Login_Response::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Login_Response::clear_uid() {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    uid_->clear();
  }
  clear_has_uid();
}
inline const ::std::string& Login_Response::uid() const {
  return *uid_;
}
inline void Login_Response::set_uid(const ::std::string& value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void Login_Response::set_uid(const char* value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void Login_Response::set_uid(const void* value, size_t size) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Login_Response::mutable_uid() {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  return uid_;
}
inline ::std::string* Login_Response::release_uid() {
  clear_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uid_;
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Login_Response::set_allocated_uid(::std::string* uid) {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    delete uid_;
  }
  if (uid) {
    set_has_uid();
    uid_ = uid;
  } else {
    clear_has_uid();
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes fromuid = 2;
inline bool Login_Response::has_fromuid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Login_Response::set_has_fromuid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Login_Response::clear_has_fromuid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Login_Response::clear_fromuid() {
  if (fromuid_ != &::google::protobuf::internal::kEmptyString) {
    fromuid_->clear();
  }
  clear_has_fromuid();
}
inline const ::std::string& Login_Response::fromuid() const {
  return *fromuid_;
}
inline void Login_Response::set_fromuid(const ::std::string& value) {
  set_has_fromuid();
  if (fromuid_ == &::google::protobuf::internal::kEmptyString) {
    fromuid_ = new ::std::string;
  }
  fromuid_->assign(value);
}
inline void Login_Response::set_fromuid(const char* value) {
  set_has_fromuid();
  if (fromuid_ == &::google::protobuf::internal::kEmptyString) {
    fromuid_ = new ::std::string;
  }
  fromuid_->assign(value);
}
inline void Login_Response::set_fromuid(const void* value, size_t size) {
  set_has_fromuid();
  if (fromuid_ == &::google::protobuf::internal::kEmptyString) {
    fromuid_ = new ::std::string;
  }
  fromuid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Login_Response::mutable_fromuid() {
  set_has_fromuid();
  if (fromuid_ == &::google::protobuf::internal::kEmptyString) {
    fromuid_ = new ::std::string;
  }
  return fromuid_;
}
inline ::std::string* Login_Response::release_fromuid() {
  clear_has_fromuid();
  if (fromuid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = fromuid_;
    fromuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Login_Response::set_allocated_fromuid(::std::string* fromuid) {
  if (fromuid_ != &::google::protobuf::internal::kEmptyString) {
    delete fromuid_;
  }
  if (fromuid) {
    set_has_fromuid();
    fromuid_ = fromuid;
  } else {
    clear_has_fromuid();
    fromuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CreateRole_Request

// optional sint32 figure = 1;
inline bool CreateRole_Request::has_figure() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CreateRole_Request::set_has_figure() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CreateRole_Request::clear_has_figure() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CreateRole_Request::clear_figure() {
  figure_ = 0;
  clear_has_figure();
}
inline ::google::protobuf::int32 CreateRole_Request::figure() const {
  return figure_;
}
inline void CreateRole_Request::set_figure(::google::protobuf::int32 value) {
  set_has_figure();
  figure_ = value;
}

// optional bytes name = 2;
inline bool CreateRole_Request::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CreateRole_Request::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CreateRole_Request::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CreateRole_Request::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& CreateRole_Request::name() const {
  return *name_;
}
inline void CreateRole_Request::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void CreateRole_Request::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void CreateRole_Request::set_name(const void* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CreateRole_Request::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* CreateRole_Request::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CreateRole_Request::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Role

// optional sint32 figure = 1;
inline bool Role::has_figure() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Role::set_has_figure() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Role::clear_has_figure() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Role::clear_figure() {
  figure_ = 0;
  clear_has_figure();
}
inline ::google::protobuf::int32 Role::figure() const {
  return figure_;
}
inline void Role::set_figure(::google::protobuf::int32 value) {
  set_has_figure();
  figure_ = value;
}

// optional sint32 viplv = 2;
inline bool Role::has_viplv() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Role::set_has_viplv() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Role::clear_has_viplv() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Role::clear_viplv() {
  viplv_ = 0;
  clear_has_viplv();
}
inline ::google::protobuf::int32 Role::viplv() const {
  return viplv_;
}
inline void Role::set_viplv(::google::protobuf::int32 value) {
  set_has_viplv();
  viplv_ = value;
}

// optional sint32 viptub = 3;
inline bool Role::has_viptub() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Role::set_has_viptub() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Role::clear_has_viptub() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Role::clear_viptub() {
  viptub_ = 0;
  clear_has_viptub();
}
inline ::google::protobuf::int32 Role::viptub() const {
  return viptub_;
}
inline void Role::set_viptub(::google::protobuf::int32 value) {
  set_has_viptub();
  viptub_ = value;
}

// optional sint32 mclv = 4;
inline bool Role::has_mclv() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Role::set_has_mclv() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Role::clear_has_mclv() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Role::clear_mclv() {
  mclv_ = 0;
  clear_has_mclv();
}
inline ::google::protobuf::int32 Role::mclv() const {
  return mclv_;
}
inline void Role::set_mclv(::google::protobuf::int32 value) {
  set_has_mclv();
  mclv_ = value;
}

// optional sint32 mctub = 5;
inline bool Role::has_mctub() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Role::set_has_mctub() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Role::clear_has_mctub() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Role::clear_mctub() {
  mctub_ = 0;
  clear_has_mctub();
}
inline ::google::protobuf::int32 Role::mctub() const {
  return mctub_;
}
inline void Role::set_mctub(::google::protobuf::int32 value) {
  set_has_mctub();
  mctub_ = value;
}

// optional sint32 newbies = 6;
inline bool Role::has_newbies() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Role::set_has_newbies() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Role::clear_has_newbies() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Role::clear_newbies() {
  newbies_ = 0;
  clear_has_newbies();
}
inline ::google::protobuf::int32 Role::newbies() const {
  return newbies_;
}
inline void Role::set_newbies(::google::protobuf::int32 value) {
  set_has_newbies();
  newbies_ = value;
}

// optional bytes name = 7;
inline bool Role::has_name() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Role::set_has_name() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Role::clear_has_name() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Role::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Role::name() const {
  return *name_;
}
inline void Role::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Role::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Role::set_name(const void* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Role::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* Role::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Role::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Hero

// optional sint32 id = 1;
inline bool Hero::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Hero::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Hero::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Hero::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 Hero::id() const {
  return id_;
}
inline void Hero::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// optional sint32 tid = 2;
inline bool Hero::has_tid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Hero::set_has_tid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Hero::clear_has_tid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Hero::clear_tid() {
  tid_ = 0;
  clear_has_tid();
}
inline ::google::protobuf::int32 Hero::tid() const {
  return tid_;
}
inline void Hero::set_tid(::google::protobuf::int32 value) {
  set_has_tid();
  tid_ = value;
}

// optional sint32 level = 3;
inline bool Hero::has_level() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Hero::set_has_level() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Hero::clear_has_level() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Hero::clear_level() {
  level_ = 0;
  clear_has_level();
}
inline ::google::protobuf::int32 Hero::level() const {
  return level_;
}
inline void Hero::set_level(::google::protobuf::int32 value) {
  set_has_level();
  level_ = value;
}

// optional sint32 exptub = 4;
inline bool Hero::has_exptub() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Hero::set_has_exptub() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Hero::clear_has_exptub() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Hero::clear_exptub() {
  exptub_ = 0;
  clear_has_exptub();
}
inline ::google::protobuf::int32 Hero::exptub() const {
  return exptub_;
}
inline void Hero::set_exptub(::google::protobuf::int32 value) {
  set_has_exptub();
  exptub_ = value;
}

// optional sint32 advlv = 5;
inline bool Hero::has_advlv() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Hero::set_has_advlv() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Hero::clear_has_advlv() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Hero::clear_advlv() {
  advlv_ = 0;
  clear_has_advlv();
}
inline ::google::protobuf::int32 Hero::advlv() const {
  return advlv_;
}
inline void Hero::set_advlv(::google::protobuf::int32 value) {
  set_has_advlv();
  advlv_ = value;
}

// optional sint32 qualv = 6;
inline bool Hero::has_qualv() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Hero::set_has_qualv() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Hero::clear_has_qualv() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Hero::clear_qualv() {
  qualv_ = 0;
  clear_has_qualv();
}
inline ::google::protobuf::int32 Hero::qualv() const {
  return qualv_;
}
inline void Hero::set_qualv(::google::protobuf::int32 value) {
  set_has_qualv();
  qualv_ = value;
}

// -------------------------------------------------------------------

// HeroList

// repeated .Cmd.Hero list = 1;
inline int HeroList::list_size() const {
  return list_.size();
}
inline void HeroList::clear_list() {
  list_.Clear();
}
inline const ::Cmd::Hero& HeroList::list(int index) const {
  return list_.Get(index);
}
inline ::Cmd::Hero* HeroList::mutable_list(int index) {
  return list_.Mutable(index);
}
inline ::Cmd::Hero* HeroList::add_list() {
  return list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Cmd::Hero >&
HeroList::list() const {
  return list_;
}
inline ::google::protobuf::RepeatedPtrField< ::Cmd::Hero >*
HeroList::mutable_list() {
  return &list_;
}

// -------------------------------------------------------------------

// Item

// optional sint32 id = 1;
inline bool Item::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Item::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Item::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Item::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 Item::id() const {
  return id_;
}
inline void Item::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// optional sint32 tid = 2;
inline bool Item::has_tid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Item::set_has_tid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Item::clear_has_tid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Item::clear_tid() {
  tid_ = 0;
  clear_has_tid();
}
inline ::google::protobuf::int32 Item::tid() const {
  return tid_;
}
inline void Item::set_tid(::google::protobuf::int32 value) {
  set_has_tid();
  tid_ = value;
}

// optional sint32 num = 3;
inline bool Item::has_num() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Item::set_has_num() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Item::clear_has_num() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Item::clear_num() {
  num_ = 0;
  clear_has_num();
}
inline ::google::protobuf::int32 Item::num() const {
  return num_;
}
inline void Item::set_num(::google::protobuf::int32 value) {
  set_has_num();
  num_ = value;
}

// optional sint32 level = 4;
inline bool Item::has_level() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Item::set_has_level() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Item::clear_has_level() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Item::clear_level() {
  level_ = 0;
  clear_has_level();
}
inline ::google::protobuf::int32 Item::level() const {
  return level_;
}
inline void Item::set_level(::google::protobuf::int32 value) {
  set_has_level();
  level_ = value;
}

// optional sint32 htid = 5;
inline bool Item::has_htid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Item::set_has_htid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Item::clear_has_htid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Item::clear_htid() {
  htid_ = 0;
  clear_has_htid();
}
inline ::google::protobuf::int32 Item::htid() const {
  return htid_;
}
inline void Item::set_htid(::google::protobuf::int32 value) {
  set_has_htid();
  htid_ = value;
}

// -------------------------------------------------------------------

// ItemList

// repeated .Cmd.Item list = 1;
inline int ItemList::list_size() const {
  return list_.size();
}
inline void ItemList::clear_list() {
  list_.Clear();
}
inline const ::Cmd::Item& ItemList::list(int index) const {
  return list_.Get(index);
}
inline ::Cmd::Item* ItemList::mutable_list(int index) {
  return list_.Mutable(index);
}
inline ::Cmd::Item* ItemList::add_list() {
  return list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Cmd::Item >&
ItemList::list() const {
  return list_;
}
inline ::google::protobuf::RepeatedPtrField< ::Cmd::Item >*
ItemList::mutable_list() {
  return &list_;
}

// -------------------------------------------------------------------

// Team

// repeated sint32 list = 1;
inline int Team::list_size() const {
  return list_.size();
}
inline void Team::clear_list() {
  list_.Clear();
}
inline ::google::protobuf::int32 Team::list(int index) const {
  return list_.Get(index);
}
inline void Team::set_list(int index, ::google::protobuf::int32 value) {
  list_.Set(index, value);
}
inline void Team::add_list(::google::protobuf::int32 value) {
  list_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
Team::list() const {
  return list_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
Team::mutable_list() {
  return &list_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace Cmd

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_Cmds_2eproto__INCLUDED
